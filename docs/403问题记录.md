# 403 问题调试记录

## 问题描述

在实现用户资料更新功能时，前端调用 `/api/user/update` 接口返回 403 错误。

## 问题分析

1. **初始状态**
   - 前端已实现登录并保存 token
   - 后端已配置 Spring Security
   - 请求时返回 403 Forbidden

2. **排查思路**
   - 检查前端 token 传递
   - 检查后端认证配置
   - 添加调试日志跟踪认证流程

## 解决过程

### 1. 添加前端调试日志

在请求拦截器中添加日志，确认 token 的传递：

```javascript
// request.js
service.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token')
    console.log('当前token:', token)
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`
    }
    console.log('请求配置:', config)
    return config
  }
)
```

### 2. 实现 JWT 认证过滤器

创建 `JwtAuthenticationFilter.java`：
```java
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private static final String JWT_SECRET = "your-secret-key";

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        try {
            String token = extractToken(request);
            log.debug("提取到的token: {}", token);

            if (token != null) {
                Claims claims = validateToken(token);
                if (claims != null) {
                    setAuthentication(claims);
                }
            }
        } catch (Exception e) {
            log.error("处理token时发生错误", e);
        }
        chain.doFilter(request, response);
    }
}
```

### 3. 配置 Security

在 `SecurityConfig.java` 中添加过滤器：
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    log.debug("配置 Security 规则");
    http
        .cors().and()
        .csrf().disable()
        .authorizeRequests()
        .antMatchers("/user/register", "/user/register/admin", "/user/login").permitAll()
        .anyRequest().authenticated()
        .and()
        .addFilterBefore(new JwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
        .formLogin().disable()
        .httpBasic().disable();
    log.debug("Security 规则配置完成");
}
```

### 4. 在控制器中添加日志

在 `UserController.java` 中添加调试日志：
```java
@PostMapping("/update")
public Result<User> update(@RequestBody UpdateUserDTO updateUserDTO) {
    log.debug("接收到用户更新请求：{}", updateUserDTO);
    try {
        User user = userService.update(updateUserDTO);
        log.debug("用户更新成功：{}", user);
        return Result.success(user);
    } catch (Exception e) {
        log.error("用户更新失败", e);
        return Result.error(e.getMessage());
    }
}
```

## 问题解决

通过添加 JWT 认证过滤器，完成了完整的认证流程：

1. 前端发送请求时携带 token
2. JWT 过滤器拦截请求并验证 token
3. 验证成功后设置 SecurityContext 中的认证信息
4. Spring Security 允许请求继续处理

## 经验总结

1. **认证流程完整性**
   - 需要确保从 token 生成到验证的完整流程
   - 前后端 token 传递机制的一致性
   - 正确配置 Security 过滤器链

2. **调试方法**
   - 在关键节点添加日志
   - 跟踪完整请求流程
   - 验证每个环节的数据传递

3. **最佳实践**
   - JWT 密钥的统一管理
   - 合理的日志级别设置
   - 清晰的错误提示

## 后续优化建议

1. 将 JWT 相关配置抽取到配置文件
2. 添加 token 过期处理机制
3. 完善权限控制机制
4. 优化错误处理和提示信息 